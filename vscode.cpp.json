{
  "hash": {
    "prefix": "hash",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace hashing",
      "{",
      "using hash_result_type = uint64;",
      "",
      "constexpr hash_result_type hash_base = std::array{449, 100003, 1000003, 1000000007}[0];",
      "constexpr hash_result_type hash_mod  = std::array{998244353ULL, 4294967291ULL}[0];",
      "",
      "static_assert(hash_base < hash_mod);",
      "static_assert(hash_mod <= std::numeric_limits<hash_result_type>::max() / hash_mod);",
      "",
      "template<typename _Tp>",
      "struct Hash : std::hash<_Tp>",
      "{ using value_type = _Tp; };",
      "",
      "template<std::integral _Tp>",
      "struct Hash<_Tp>",
      "{",
      "    using value_type = _Tp;",
      "",
      "    [[nodiscard]] static constexpr",
      "    hash_result_type",
      "    splitmix64(hash_result_type __value) noexcept",
      "    {",
      "        __value += 0x9e3779b97f4a7c15;",
      "        __value = (__value ^ (__value >> 30)) * 0xbf58476d1ce4e5b9;",
      "        __value = (__value ^ (__value >> 27)) * 0x94d049bb133111eb;",
      "        return __value ^ (__value >> 31);",
      "    }",
      "",
      "    [[nodiscard]]",
      "    hash_result_type",
      "    operator()(value_type __value) const noexcept",
      "    {",
      "        static const hash_result_type fixed_random =",
      "            std::chrono::steady_clock::now().time_since_epoch().count();",
      "",
      "        return splitmix64(fixed_random + __value);",
      "    }",
      "};",
      "",
      "template<typename _Ft, typename _St>",
      "struct Hash<std::pair<_Ft, _St>>",
      "{",
      "    using value_type = std::pair<_Ft, _St>;",
      "",
      "    [[nodiscard]] constexpr",
      "    hash_result_type",
      "    operator()(const value_type& __value) const noexcept",
      "    {",
      "        return (Hash<_Ft>{}(__value.first) % hash_mod * hash_base % hash_mod + Hash<_St>{}(__value.second) % hash_mod) % hash_mod;",
      "    }",
      "};",
      "",
      "template<typename... _Args>",
      "struct Hash<std::tuple<_Args...>>",
      "{",
      "    using value_type = std::tuple<_Args...>;",
      "",
      "    [[nodiscard]] constexpr",
      "    hash_result_type",
      "    operator()(const value_type& __value) const noexcept",
      "    {",
      "        return std::apply([](auto&&... args) -> hash_result_type",
      "        {",
      "            hash_result_type result = 0;",
      "",
      "            for (const hash_result_type& i : std::array{{Hash<_Args...>{}(args)...}})",
      "            {",
      "                result *= hash_base;",
      "                result %= hash_mod;",
      "                result += i % hash_mod;",
      "                result %= hash_mod;",
      "            }",
      "",
      "            return result;",
      "        }, __value);",
      "    }",
      "};",
      "",
      "template<std::ranges::input_range _Tp>",
      "struct Hash<_Tp>",
      "{",
      "    using value_type = _Tp;",
      "",
      "    [[nodiscard]] constexpr",
      "    hash_result_type",
      "    operator()(const value_type& __value) const noexcept",
      "    {",
      "        hash_result_type result = 0;",
      "",
      "        auto begin = std::ranges::begin(__value);",
      "        auto end   = std::ranges::end(__value);",
      "",
      "        if constexpr (",
      "            std::is_array_v<std::remove_reference_t<value_type>> and",
      "            std::is_same_v<std::remove_extent_t<std::remove_reference_t<value_type>>, char>)",
      "        {",
      "            --end;",
      "        }",
      "",
      "        for (; begin != end; ++begin)",
      "        {",
      "            const auto& i = *begin;",
      "",
      "            result *= hash_base;",
      "            result %= hash_mod;",
      "",
      "            if constexpr (requires{ value_type::value_type; })",
      "            {",
      "                result += Hash<typename _Tp::value_type>{}(i) % hash_mod;",
      "            }",
      "            else",
      "            {",
      "                result += Hash<std::remove_reference_t<decltype(i)>>{}(i) % hash_mod;",
      "            }",
      "",
      "            result %= hash_mod;",
      "        }",
      "",
      "        return result;",
      "    }",
      "};",
      "",
      "template<>",
      "struct Hash<void>",
      "{",
      "    template<typename _Tp>",
      "    [[nodiscard]] constexpr",
      "    hash_result_type",
      "    operator()(const _Tp& __value) const noexcept",
      "    {",
      "        return Hash<_Tp>{}(__value);",
      "    }",
      "};",
      "",
      "class RangeHash",
      "{",
      "public:",
      "",
      "    using container_type = std::vector<std::pair<hash_result_type, hash_result_type>>;",
      "    using size_type = std::size_t;",
      "",
      "    static constexpr auto npos = static_cast<size_type>(-1);",
      "",
      "    RangeHash() noexcept",
      "        : _M_c{{0, 1}}",
      "    { };",
      "",
      "    template<std::input_iterator _Iter, std::sentinel_for<_Iter> _Sent>",
      "    RangeHash(_Iter __first, _Sent __last)",
      "        : RangeHash()",
      "    { append(__first, __last); }",
      "",
      "    template<std::ranges::input_range _Range>",
      "    RangeHash(_Range&& __r)",
      "        : RangeHash()",
      "    { append(std::forward<_Range>(__r)); }",
      "",
      "    template<typename _Tp>",
      "    void",
      "    push_back(const _Tp& __value)",
      "    {",
      "        _M_c.emplace_back(",
      "            (_M_c.back().first * hash_base % hash_mod + Hash<void>{}(__value) % hash_mod) % hash_mod,",
      "            _M_c.back().second * hash_base % hash_mod);",
      "    }",
      "",
      "    template<std::input_iterator _Iter, std::sentinel_for<_Iter> _Sent>",
      "    void",
      "    append(_Iter __first, _Sent __last)",
      "    {",
      "        if constexpr (",
      "            std::sized_sentinel_for<_Sent, _Iter> and",
      "            requires(container_type c) { c.reserve(std::size_t{}); })",
      "        {",
      "            _M_c.reserve(_M_c.size() + static_cast<std::size_t>(std::ranges::distance(__first, __last)));",
      "        }",
      "",
      "        for (; __first != __last; ++__first)",
      "        {",
      "            push_back(*__first);",
      "        }",
      "    }",
      "",
      "    template<std::ranges::input_range _Range>",
      "    void",
      "    append(_Range&& __r)",
      "    { append(std::ranges::begin(__r), std::ranges::end(__r)); }",
      "",
      "    void",
      "    pop_back(size_type __n = 1)",
      "    { _M_c.resize(_M_c.size() - std::min(__n, _M_c.size() - 1)); }",
      "",
      "    [[nodiscard]] size_type",
      "    size() const noexcept",
      "    { return _M_c.size() - 1; }",
      "",
      "    [[nodiscard]] bool",
      "    empty() const noexcept",
      "    { return size() == 0; }",
      "",
      "    [[nodiscard]] hash_result_type",
      "    operator()() const noexcept",
      "    { return _M_c.back().first; }",
      "",
      "    [[nodiscard]] hash_result_type",
      "    operator()(size_type __pos, size_type __n) const noexcept",
      "    {",
      "        if (__pos >= size())",
      "        {",
      "            return 0;",
      "        }",
      "",
      "        if (__pos + __n >= _M_c.size())",
      "        {",
      "            __n = _M_c.size() - __pos - 1;",
      "        }",
      "",
      "        return (_M_c[__pos + __n].first + hash_mod - _M_c[__pos].first * _M_c[__n].second % hash_mod) % hash_mod;",
      "    }",
      "",
      "    [[nodiscard]] hash_result_type",
      "    operator[](size_type __i) const noexcept",
      "    { return (*this)(__i, __i); }",
      "",
      "    [[nodiscard]] hash_result_type",
      "    front(size_type __n = 1) const noexcept",
      "    { return _M_c[std::min(__n, size())].first; }",
      "",
      "    [[nodiscard]] hash_result_type",
      "    back(size_type __n = 1) const noexcept",
      "    { return empty() ? 0 : (*this)(size() - std::min(__n, size()), std::min(__n, size())); }",
      "",
      "    [[nodiscard]] bool",
      "    operator==(const RangeHash& __rhs) const noexcept",
      "    { return (*this)() == __rhs(); }",
      "",
      "    [[nodiscard]] bool",
      "    operator!=(const RangeHash& __rhs) const noexcept",
      "    { return (*this)() != __rhs(); }",
      "",
      "    [[nodiscard]] bool",
      "    operator<(const RangeHash& __rhs) const noexcept",
      "    { return (*this)() < __rhs(); }",
      "",
      "    [[nodiscard]] bool",
      "    operator<=(const RangeHash& __rhs) const noexcept",
      "    { return (*this)() <= __rhs(); }",
      "",
      "    [[nodiscard]] bool",
      "    operator>(const RangeHash& __rhs) const noexcept",
      "    { return (*this)() > __rhs(); }",
      "",
      "    [[nodiscard]] bool",
      "    operator>=(const RangeHash& __rhs) const noexcept",
      "    { return (*this)() >= __rhs(); }",
      "",
      "    [[nodiscard]] bool",
      "    matches(const RangeHash& __h, size_type __pos) const noexcept",
      "    { return (*this)(__pos, __h.size()) == __h(); }",
      "",
      "    [[nodiscard]] bool",
      "    starts_with(const RangeHash& __h) const noexcept",
      "    { return matches(__h, 0); }",
      "",
      "    [[nodiscard]] bool",
      "    ends_with(const RangeHash& __h) const noexcept",
      "    { return matches(__h, size() - std::min(__h.size(), size())); }",
      "",
      "    [[nodiscard]] size_type",
      "    find(const RangeHash& __h, size_type __pos = 0) const noexcept",
      "    {",
      "        const auto n1 = size(), n2 = __h.size();",
      "",
      "        for (; __pos + n2 <= n1; ++__pos)",
      "        {",
      "            if (matches(__h, __pos))",
      "            {",
      "                return __pos;",
      "            }",
      "        }",
      "",
      "        return npos;",
      "    }",
      "",
      "    [[nodiscard]] size_type",
      "    rfind(const RangeHash& __h, size_type __pos = std::numeric_limits<size_type>::max()) const noexcept",
      "    {",
      "        const auto n1 = size(), n2 = __h.size();",
      "",
      "        if (__pos >= size())",
      "        {",
      "            __pos = size();",
      "        }",
      "        else",
      "        {",
      "            ++__pos;",
      "        }",
      "",
      "        while (__pos--)",
      "        {",
      "            if (matches(__h, __pos))",
      "            {",
      "                return __pos;",
      "            }",
      "        }",
      "",
      "        return npos;",
      "    }",
      "",
      "    [[nodiscard]] bool",
      "    contains(const RangeHash& __h) const noexcept",
      "    { return find(__h) != npos; }",
      "",
      "    enum OverlapMode",
      "    {",
      "        AllowOverlap,",
      "        NoOverlap",
      "    };",
      "",
      "    [[nodiscard]] size_type",
      "    count(const RangeHash& __h, OverlapMode __mode = AllowOverlap) const noexcept",
      "    {",
      "        if (__h.size() == 0)",
      "        {",
      "            return 0;",
      "        }",
      "",
      "        size_type cnt = 0;",
      "",
      "        if (__mode == AllowOverlap)",
      "        {",
      "            for (size_type pos = find(__h); pos != npos; ++cnt, pos = find(__h, pos + 1));",
      "        }",
      "        else",
      "        {",
      "            for (size_type pos = find(__h); pos != npos; ++cnt, pos = find(__h, pos + __h.size()));",
      "        }",
      "",
      "        return cnt;",
      "    }",
      "",
      "    [[nodiscard]] size_type",
      "    longest_suffix_prefix_overlap(const RangeHash& __h) const noexcept",
      "    {",
      "        for (size_type i = std::min(size(), __h.size()); i > 0; --i)",
      "        {",
      "            if (back(i) == __h.front(i))",
      "            {",
      "                return i;",
      "            }",
      "        }",
      "",
      "        return 0;",
      "    }",
      "",
      "private:",
      "",
      "    container_type _M_c;",
      "};",
      "}} // namespace huanhuanonly::hashing"
    ],
    "description": "hash"
  },

  "z_function": {
    "prefix": "z_function",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace string",
      "{",
      "template<",
      "    std::random_access_iterator _Iter,",
      "    std::sized_sentinel_for<_Iter> _Sent,",
      "    std::random_access_iterator _Out,",
      "    typename _Comp = std::ranges::equal_to,",
      "    typename _Proj = std::identity>",
      "constexpr void z_function(_Iter __first, _Sent __last, _Out __result, _Comp __comp = {}, _Proj __proj = {})",
      "{",
      "    if (__first == __last)",
      "    {",
      "        return;",
      "    }",
      "",
      "    auto l = __first, r = __first;",
      "",
      "    *__result = std::ranges::distance(__first, __last);",
      "",
      "    auto oit = __result + 1;",
      "",
      "    for (auto it = __first + 1; it != __last; ++it, ++oit)",
      "    {",
      "        if (it <= r)",
      "        {",
      "            *oit = std::min(__result[it - l], static_cast<std::remove_reference_t<std::iter_reference_t<_Out>>>(r - it + 1));",
      "        }",
      "        else",
      "        {",
      "            *oit = 0;",
      "        }",
      "",
      "        for (; it + *oit != __last and",
      "            __comp(std::invoke(__proj, __first[*oit]), std::invoke(__proj, it[*oit])); ++*oit);",
      "",
      "        if (const auto cr = it + *oit - 1; r < cr)",
      "        {",
      "            l = it;",
      "            r = cr;",
      "        }",
      "    }",
      "}",
      "",
      "template<",
      "    std::ranges::random_access_range _Range,",
      "    std::random_access_iterator _Out,",
      "    typename _Comp = std::ranges::equal_to,",
      "    typename _Proj = std::identity>",
      "constexpr void z_function(_Range&& __r, _Out __out, _Comp __comp = {}, _Proj __proj = {})",
      "{ z_function(std::ranges::begin(__r), std::ranges::end(__r), std::move(__out), std::move(__comp), std::move(__proj)); }",
      "}} // namespace huanhuanonly::string"
    ],
    "description": "z_function"
  },

  "DisjointSet [with undo]": {
    "prefix": "DisjointSet",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace data_structure",
      "{",
      "class DisjointSet",
      "{",
      "public:",
      "",
      "    using size_type = int;",
      "",
      "    struct node",
      "    {",
      "        size_type parent;",
      "        size_type size;",
      "    };",
      "",
      "    struct change_record",
      "    {",
      "        std::pair<size_type&, size_type> parent;",
      "        std::pair<size_type&, size_type> size;",
      "    };",
      "",
      "    explicit",
      "    DisjointSet(size_type __n)",
      "        : _M_tree(__n)",
      "    { reset(); }",
      "",
      "    [[nodiscard]] size_type",
      "    find(size_type u) const",
      "    { return is_root(u) ? u : find(_M_tree[u].parent); }",
      "",
      "    bool",
      "    unite(size_type u, size_type v)",
      "    {",
      "        size_type fu = find(u);",
      "        size_type fv = find(v);",
      "",
      "        if (fu == fv)",
      "        {",
      "            return false;",
      "        }",
      "",
      "        if (_M_tree[fu].size < _M_tree[fv].size)",
      "        {",
      "            std::swap(fu, fv);",
      "        }",
      "",
      "        _M_history.emplace(change_record{",
      "                {_M_tree[fv].parent, _M_tree[fv].parent},",
      "                {_M_tree[fu].size,   _M_tree[fu].size  }});",
      "        ",
      "        _M_tree[fv].parent = fu;",
      "        _M_tree[fu].size += _M_tree[fv].size;",
      "",
      "        return true;",
      "    }",
      "",
      "    [[nodiscard]] bool",
      "    is_root(size_type u) const",
      "    { return _M_tree[u].parent == u; }",
      "",
      "    [[nodiscard]] bool",
      "    connected(size_type u, size_type v) const",
      "    { return find(u) == find(v); }",
      "",
      "    void",
      "    expand(size_type __n)",
      "    {",
      "        const size_type old_size = size();",
      "        _M_tree.resize(old_size + __n);",
      "",
      "        for (size_type i = old_size; i < old_size + __n; ++i)",
      "        {",
      "            _M_tree[i].parent = i;",
      "            _M_tree[i].size = 1;",
      "        }",
      "    }",
      "",
      "    void",
      "    reset()",
      "    {",
      "        for (size_type i = 0; i < size(); ++i)",
      "        {",
      "            _M_tree[i].parent = i;",
      "            _M_tree[i].size = 1;",
      "        }",
      "    }",
      "",
      "    [[nodiscard]] size_type",
      "    size() const",
      "    { return static_cast<size_type>(_M_tree.size()); }",
      "",
      "    [[nodiscard]] size_type",
      "    component_size(size_type u) const",
      "    { return _M_tree[find(u)].size; }",
      "",
      "    [[nodiscard]] size_type",
      "    checkpoint() const",
      "    { return static_cast<size_type>(_M_history.size()); }",
      "",
      "    void",
      "    undo()",
      "    {",
      "        if (not _M_history.empty())",
      "        {",
      "            const auto& rec = _M_history.top();",
      "",
      "            rec.parent.first = rec.parent.second;",
      "            rec.size.first = rec.size.second;",
      "",
      "            _M_history.pop();",
      "        }",
      "    }",
      "",
      "    void",
      "    rollback(size_type __cp)",
      "    { for (; checkpoint() > __cp; undo()); }",
      "",
      "private:",
      "",
      "    std::vector<node> _M_tree;",
      "    std::stack<change_record, std::vector<change_record>> _M_history;",
      "};",
      "}} // namespace huanhuanonly::data_structure"
    ],
    "description": "DisjointSet [with undo]"
  },

  "DisjointSet [unite by size]": {
    "prefix": "DisjointSet",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace data_structure",
      "{",
      "class DisjointSet",
      "{",
      "public:",
      "",
      "    using size_type = int;",
      "",
      "    struct node",
      "    {",
      "        size_type parent;",
      "        size_type size;",
      "    };",
      "",
      "    explicit",
      "    DisjointSet(size_type __n)",
      "        : _M_tree(__n)",
      "    { reset(); }",
      "",
      "    [[nodiscard]] size_type",
      "    find(size_type u) const",
      "    { return is_root(u) ? u : find(_M_tree[u].parent); }",
      "",
      "    bool",
      "    unite(size_type u, size_type v)",
      "    {",
      "        const size_type fu = find(u);",
      "        const size_type fv = find(v);",
      "",
      "        if (fu != fv)",
      "        {",
      "            _M_tree[fv].parent = fu;",
      "            _M_tree[fu].size += _M_tree[fv].size;",
      "            return true;",
      "        }",
      "        else",
      "        {",
      "            return false;",
      "        }",
      "    }",
      "",
      "    [[nodiscard]] bool",
      "    is_root(size_type u) const",
      "    { return _M_tree[u].parent == u; }",
      "",
      "    [[nodiscard]] bool",
      "    connected(size_type u, size_type v)",
      "    { return find(u) == find(v); }",
      "",
      "    void",
      "    expand(size_type __n)",
      "    {",
      "        const size_type old_size = size();",
      "        _M_tree.resize(old_size + __n);",
      "",
      "        for (size_type i = old_size; i < old_size + __n; ++i)",
      "        {",
      "            _M_tree[i].parent = i;",
      "            _M_tree[i].size = 1;",
      "        }",
      "    }",
      "",
      "    void",
      "    reset()",
      "    {",
      "        for (size_type i = 0; i < size(); ++i)",
      "        {",
      "            _M_tree[i].parent = i;",
      "            _M_tree[i].size = 1;",
      "        }",
      "    }",
      "",
      "    [[nodiscard]] size_type",
      "    size()",
      "    { return static_cast<size_type>(_M_tree.size()); }",
      "",
      "    [[nodiscard]] size_type",
      "    component_size(size_type u) const",
      "    { return _M_tree[find(u)].size; }",
      "",
      "private:",
      "",
      "    std::vector<node> _M_tree;",
      "};",
      "}} // namespace huanhuanonly::data_structure"
    ],
    "description": "DisjointSet [unite by size]"
  },

  "LazySegmentTree": {
    "prefix": "LazySegmentTree",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace data_structure",
      "{",
      "struct MakeLazyFunc",
      "{",
      "    struct Add",
      "    {",
      "        constexpr void",
      "        operator()(const auto& that, const auto& value) const noexcept",
      "        {",
      "            that.value += value;",
      "            that.lazy  += value;",
      "        }",
      "    };",
      "",
      "    struct RangeAdd",
      "    {",
      "        constexpr void",
      "        operator()(const auto& that, const auto& value) const noexcept",
      "        {",
      "            that.value += value * that.size;",
      "            that.lazy  += value;",
      "        }",
      "    };",
      "",
      "    struct Assign",
      "    {",
      "        constexpr void",
      "        operator()(const auto& that, const auto& value) const noexcept",
      "        {",
      "            that.value = value;",
      "            that.lazy  = value;",
      "        }",
      "    };",
      "",
      "    struct Merge",
      "    {",
      "        constexpr void",
      "        operator()(const auto& that, const auto& value) const noexcept",
      "        {",
      "            that.value = that.merge(that.value, value);",
      "",
      "            if (that.marked)",
      "                that.lazy = that.merge(that.lazy, value);",
      "            else",
      "                that.lazy = value;",
      "        }",
      "    };",
      "};",
      "",
      "template<",
      "    typename _ValueType, typename _MergeFunc = std::plus<_ValueType>,",
      "    typename _LazyType = _ValueType, typename _MakeLazyFunc = MakeLazyFunc::RangeAdd>",
      "class LazySegmentTree : public SegmentTree<_ValueType, _MergeFunc>",
      "{",
      "public:",
      "",
      "    using parent_type     = SegmentTree<_ValueType, _MergeFunc>;",
      "",
      "    using container_type  = parent_type::container_type;",
      "    using value_type      = parent_type::value_type;",
      "    using lazy_type       = std::conditional_t<std::is_same_v<_ValueType, bool>, std::uint8_t, _LazyType>;",
      "    using reference       = parent_type::reference;",
      "    using const_reference = parent_type::const_reference;",
      "    using size_type       = parent_type::size_type;",
      "",
      "    using parent_type::size;",
      "    using parent_type::nodes_count;",
      "    ",
      "    struct lazy_build_info",
      "    {",
      "        value_type& value;",
      "        lazy_type&  lazy;",
      "        _MergeFunc& merge;",
      "",
      "        size_type size;",
      "        bool marked;",
      "    };",
      "",
      "protected:",
      "",
      "    using parent_type::ls;",
      "    using parent_type::rs;",
      "",
      "    using parent_type::push_up;",
      "",
      "    using parent_type::tree;",
      "    using parent_type::merge;",
      "",
      "public:",
      "    ",
      "    constexpr explicit",
      "    LazySegmentTree(size_type __n = 0, _MergeFunc __merge = {}, _MakeLazyFunc __makelazy = {}) noexcept",
      "        : parent_type(__n, __merge), lazy(tree.size()), marked(tree.size()), make_lazy_func(__makelazy)",
      "    { }",
      "",
      "    template<std::input_iterator _Iter, std::sentinel_for<_Iter> _Sent, typename _Proj = std::identity>",
      "    constexpr",
      "    LazySegmentTree(_Iter __first, _Sent __last, _Proj __proj = {}, _MergeFunc __merge = {}, _MakeLazyFunc __makelazy = {}) noexcept",
      "        : parent_type(__first, __last, __proj, __merge), lazy(tree.size()), marked(tree.size()), make_lazy_func(__makelazy)",
      "    { }",
      "",
      "    template<std::ranges::input_range _Range, typename _Proj = std::identity>",
      "    constexpr",
      "    LazySegmentTree(_Range&& __r, _Proj __proj = {}, _MergeFunc __merge = {}, _MakeLazyFunc __makelazy = {}) noexcept",
      "        : parent_type(std::ranges::begin(__r), std::ranges::end(__r), __proj, __merge), lazy(tree.size()), marked(tree.size()), make_lazy_func(__makelazy)",
      "    { }",
      "",
      "    constexpr",
      "    LazySegmentTree(std::initializer_list<_ValueType> __list) noexcept",
      "        : LazySegmentTree(__list.begin(), __list.end())",
      "    { }",
      "",
      "",
      "    constexpr void",
      "    range_update(size_type __l, size_type __r, const lazy_type& __value)",
      "    { _M_range_update(1, 1, size(), __l + 1, __r + 1, __value); }",
      "    ",
      "    constexpr void",
      "    resize(size_type __n)",
      "    {",
      "        parent_type::resize(__n);",
      "        lazy.resize(nodes_count(__n));",
      "        marked.resize(nodes_count(__n));",
      "    }",
      "",
      "    constexpr void",
      "    reset()",
      "    {",
      "        parent_type::reset();",
      "        std::ranges::fill(lazy, lazy_type{});",
      "        marked.assign(marked.size(), false);",
      "    }",
      "",
      "protected:",
      "",
      "    constexpr void",
      "    make_lazy(size_type __p, size_type __l, size_type __r, const lazy_type& __value)",
      "    {",
      "        make_lazy_func(lazy_build_info{",
      "            .value  = tree[__p],",
      "            .lazy   = lazy[__p],",
      "            .merge  = merge,",
      "            .size   = __r - __l + 1,",
      "            .marked = marked[__p]",
      "        }, __value);",
      "",
      "        marked[__p] = true;",
      "    }",
      "",
      "    void",
      "    push_down(size_type __p, size_type __l, size_type __r) override",
      "    {",
      "        if (marked[__p])",
      "        {",
      "            const size_type mid = (__l + __r) >> 1;",
      "",
      "            make_lazy(ls(__p), __l, mid, lazy[__p]);",
      "            make_lazy(rs(__p), mid + 1, __r, lazy[__p]);",
      "            ",
      "            lazy[__p] = lazy_type{};",
      "            marked[__p] = false;",
      "        }",
      "    }",
      "",
      "private:",
      "",
      "    constexpr void",
      "    _M_range_update(size_type __p, size_type __l, size_type __r, size_type __x, size_type __y, const lazy_type& __v)",
      "    {",
      "        if (__x <= __l and __r <= __y)",
      "        {",
      "            make_lazy(__p, __l, __r, __v);",
      "            return;",
      "        }",
      "",
      "        push_down(__p, __l, __r);",
      "",
      "        size_type mid = (__l + __r) >> 1;",
      "",
      "        if (__x <= mid)",
      "        {",
      "            _M_range_update(ls(__p), __l, mid, __x, __y, __v);",
      "        }",
      "",
      "        if (__y > mid)",
      "        {",
      "            _M_range_update(rs(__p), mid + 1, __r, __x, __y, __v);",
      "        }",
      "        ",
      "        push_up(__p);",
      "    }",
      "",
      "protected:",
      "",
      "    std::vector<lazy_type> lazy;",
      "    std::vector<bool> marked;",
      "",
      "    _MakeLazyFunc make_lazy_func;",
      "};",
      "",
      "template<std::input_iterator _Iter, std::sentinel_for<_Iter> _Sent, typename _Proj = std::identity, typename _MergeFunc = std::plus<>, typename _MakeLazyFunc = MakeLazyFunc::RangeAdd>",
      "LazySegmentTree(_Iter, _Sent, _Proj = {}, _MergeFunc = {}, _MakeLazyFunc = {}) -> LazySegmentTree<std::remove_reference_t<std::invoke_result_t<_Proj, std::iter_value_t<_Iter>>>, _MergeFunc, std::remove_reference_t<std::invoke_result_t<_Proj, std::iter_value_t<_Iter>>>, _MakeLazyFunc>;",
      "",
      "template<std::ranges::input_range _Range, typename _Proj = std::identity, typename _MergeFunc = std::plus<>, typename _MakeLazyFunc = MakeLazyFunc::RangeAdd>",
      "LazySegmentTree(_Range&&, _Proj = {}, _MergeFunc = {}, _MakeLazyFunc = {}) -> LazySegmentTree<std::remove_reference_t<std::invoke_result_t<_Proj, std::ranges::range_value_t<_Range>>>, _MergeFunc, std::remove_reference_t<std::invoke_result_t<_Proj, std::ranges::range_value_t<_Range>>>, _MakeLazyFunc>;",
      "}} // namespace huanhuanonly::data_structure"
    ],
    "description": "LazySegmentTree"
  },

  "DisjointSet [path compression]": {
    "prefix": "DisjointSet",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace data_structure",
      "{",
      "class DisjointSet",
      "{",
      "public:",
      "",
      "    using size_type = int;",
      "",
      "    explicit",
      "    DisjointSet(size_type __n)",
      "        : _M_parent(__n)",
      "    { reset(); }",
      "",
      "    [[nodiscard]] size_type",
      "    find(size_type u)",
      "    { return _M_parent[u] == u ? u : _M_parent[u] = find(_M_parent[u]); }",
      "",
      "    bool",
      "    unite(size_type u, size_type v)",
      "    {",
      "        const size_type fu = find(u);",
      "        const size_type fv = find(v);",
      "",
      "        if (fu != fv)",
      "        {",
      "            _M_parent[fv] = fu;",
      "            return true;",
      "        }",
      "        else",
      "        {",
      "            return false;",
      "        }",
      "    }",
      "",
      "    [[nodiscard]] bool",
      "    connected(size_type u, size_type v)",
      "    { return find(u) == find(v); }",
      "",
      "    void",
      "    expand(size_type __n)",
      "    {",
      "        const size_type size = static_cast<size_type>(_M_parent.size());",
      "        _M_parent.resize(size + __n);",
      "        std::iota(_M_parent.begin() + size, _M_parent.end(), size);",
      "    }",
      "",
      "    void",
      "    reset()",
      "    { std::iota(_M_parent.begin(), _M_parent.end(), 0); }",
      "",
      "    [[nodiscard]] size_type",
      "    size()",
      "    { return static_cast<size_type>(_M_parent.size()); }",
      "",
      "private:",
      "",
      "    std::vector<size_type> _M_parent;",
      "};",
      "}} // namespace huanhuanonly::data_structure"
    ],
    "description": "DisjointSet [path compression]"
  },

  "BinaryIndexedTree [Fenwick Tree]": {
    "prefix": "BinaryIndexedTree",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace data_structure",
      "{",
      "template<typename _Tp>",
      "class BinaryIndexedTree",
      "{",
      "public:",
      "",
      "    using value_type = _Tp;",
      "",
      "    constexpr BinaryIndexedTree() noexcept = default;",
      "",
      "    explicit constexpr BinaryIndexedTree(std::size_t __size) noexcept",
      "        : _M_BITree(__size + 1)",
      "    { }",
      "",
      "    [[nodiscard]] static constexpr std::size_t lowbit(std::size_t __x) noexcept",
      "    { return __x & -__x; }",
      "",
      "    constexpr void add(std::size_t __i, value_type __value = 1)",
      "    {",
      "        for (++__i; __i < _M_BITree.size(); __i += lowbit(__i))",
      "        {",
      "            _M_BITree[__i] += __value;",
      "        }",
      "    }",
      "",
      "    constexpr void subtract(std::size_t __i, value_type __value = 1)",
      "    {",
      "        for (++__i; __i < _M_BITree.size(); __i += lowbit(__i))",
      "        {",
      "            _M_BITree[__i] -= __value;",
      "        }",
      "    }",
      "",
      "    [[nodiscard]] constexpr value_type sum(std::size_t __l)",
      "    {",
      "        value_type result{};",
      "",
      "        for (++__l; __l; __l -= lowbit(__l))",
      "        {",
      "            result += _M_BITree[__l];",
      "        }",
      "",
      "        return result;",
      "    }",
      "",
      "    [[nodiscard]] constexpr value_type sum(std::size_t __l, std::size_t __r)",
      "    { return __l ? sum(__r) - sum(__l - 1) : sum(__r); }",
      "",
      "    [[nodiscard]] constexpr value_type get(std::size_t __i)",
      "    { return sum(__i, __i); }",
      "",
      "    constexpr value_type set(std::size_t __i, value_type __value)",
      "    {",
      "        value_type prev = get(__i);",
      "",
      "        prev < __value ? add(__i, __value - prev) : subtract(__i, prev - __value);",
      "",
      "        return prev;",
      "    }",
      "",
      "    constexpr void reset(std::size_t __size = static_cast<std::size_t>(-1))",
      "    { __size == static_cast<std::size_t>(-1) ? std::ranges::fill(_M_BITree, value_type{}) : _M_BITree.assign(__size + 1, value_type{}); }",
      "",
      "private:",
      "",
      "    std::vector<value_type> _M_BITree;",
      "};",
      "}} // namespace huanhuanonly::data_structure"
    ],
    "description": "BinaryIndexedTree [Fenwick Tree]"
  },

  "SegmentTree": {
    "prefix": "SegmentTree",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace data_structure",
      "{",
      "template<typename _ValueType, typename _MergeFunc = std::plus<_ValueType>>",
      "class SegmentTree",
      "{",
      "public:",
      "",
      "    using container_type = std::vector<std::conditional_t<std::is_same_v<_ValueType, bool>, std::uint8_t, _ValueType>>;",
      "",
      "    using value_type = container_type::value_type;",
      "    using reference = container_type::reference;",
      "    using const_reference = container_type::const_reference;",
      "    using size_type = std::size_t;",
      "",
      "    constexpr explicit",
      "    SegmentTree(size_type __n = 0, _MergeFunc __merge = {}) noexcept",
      "        : tree(nodes_count(__n)), merge(__merge)",
      "    { }",
      "",
      "    template<std::input_iterator _Iter, std::sentinel_for<_Iter> _Sent, typename _Proj = std::identity>",
      "    constexpr",
      "    SegmentTree(_Iter __first, _Sent __last, _Proj __proj = {}, _MergeFunc __merge = {}) noexcept",
      "        : tree(nodes_count(static_cast<size_type>(std::ranges::distance(__first, __last)))), merge(__merge)",
      "    { build(__first, __last, __proj); }",
      "",
      "    template<std::ranges::input_range _Range, typename _Proj = std::identity>",
      "    constexpr",
      "    SegmentTree(_Range&& __r, _Proj __proj = {}, _MergeFunc __merge = {}) noexcept",
      "        : SegmentTree(std::ranges::begin(__r), std::ranges::end(__r), __proj, __merge)",
      "    { }",
      "",
      "    constexpr",
      "    SegmentTree(std::initializer_list<_ValueType> __list) noexcept",
      "        : SegmentTree(__list.begin(), __list.end())",
      "    { }",
      "",
      "",
      "    [[nodiscard]] static constexpr size_type",
      "    nodes_count(size_type __n) noexcept",
      "    { return __n << 2; }",
      "",
      "    [[nodiscard]] constexpr size_type",
      "    nodes_count() const noexcept",
      "    { return tree.size(); }",
      "",
      "    [[nodiscard]] constexpr size_type",
      "    size() const noexcept",
      "    { return static_cast<size_type>(tree.size()) >> 2; }",
      "",
      "    [[nodiscard]] constexpr bool",
      "    empty() const noexcept",
      "    { return size() == 0; }",
      "",
      "    constexpr void",
      "    resize(size_type __n)",
      "    { tree.resize(nodes_count(__n)); }",
      "",
      "    ",
      "    template<typename _Callback>",
      "    requires std::invocable<_Callback, reference>",
      "    constexpr void",
      "    for_each(size_type __l, size_type __r, _Callback __func)",
      "    { _M_for_each(1, 1, size(), __l + 1, __r + 1, __func); }",
      "    ",
      "    template<typename _Callback>",
      "    requires std::invocable<_Callback, reference>",
      "    constexpr void",
      "    for_each(_Callback __func)",
      "    { empty() ? void() : for_each(0, size() - 1, __func); }",
      "",
      "    template<typename _Callback>",
      "    requires std::invocable<_Callback, reference>",
      "    constexpr void",
      "    for_each_segment(size_type __l, size_type __r, _Callback __func)",
      "    { _M_for_each_segment(1, 1, size(), __l + 1, __r + 1, __func); }",
      "    ",
      "    template<typename _Callback>",
      "    requires std::invocable<_Callback, reference>",
      "    constexpr void",
      "    for_each_segment(_Callback __func)",
      "    { empty() ? void() : for_each_segment(0, size() - 1, __func); }",
      "",
      "",
      "    template<std::input_iterator _Iter, std::sentinel_for<_Iter> _Sent, typename _Proj = std::identity>",
      "    requires std::assignable_from<value_type&, std::invoke_result_t<_Proj, std::iter_reference_t<_Iter>>>",
      "    constexpr void",
      "    build(size_type __l, size_type __r, _Iter __first, _Sent __last, _Proj __proj = {})",
      "    {",
      "        if (__first != __last)",
      "        {",
      "            for_each(__l, __r, [&](reference __ref) -> bool",
      "            {",
      "                __ref = std::invoke(__proj, *__first);",
      "                return ++__first != __last;",
      "            });",
      "        }",
      "    }",
      "",
      "    template<std::ranges::input_range _Range, typename _Proj = std::identity>",
      "    requires std::assignable_from<reference, std::invoke_result_t<_Proj, std::ranges::range_reference_t<_Range>>>",
      "    constexpr void",
      "    build(size_type __l, size_type __r, _Range&& __range, _Proj __proj = {})",
      "    { build(__l, __r, std::ranges::begin(__range), std::ranges::end(__range), __proj); }",
      "    ",
      "    template<std::input_iterator _Iter, std::sentinel_for<_Iter> _Sent, typename _Proj = std::identity>",
      "    requires std::assignable_from<reference, std::invoke_result_t<_Proj, std::iter_reference_t<_Iter>>>",
      "    constexpr void",
      "    build(_Iter __first, _Sent __last, _Proj __proj = {})",
      "    { empty() ? void() : build(0, size() - 1, __first, __last, __proj); }",
      "",
      "    template<std::ranges::input_range _Range, typename _Proj = std::identity>",
      "    requires std::assignable_from<reference, std::invoke_result_t<_Proj, std::ranges::range_reference_t<_Range>>>",
      "    constexpr void",
      "    build(_Range&& __range, _Proj __proj = {})",
      "    { build(std::ranges::begin(__range), std::ranges::end(__range), __proj); }",
      "",
      "",
      "    template<typename _Iter, typename _Proj = std::identity>",
      "    requires std::output_iterator<_Iter, std::invoke_result_t<_Proj, const_reference>>",
      "    constexpr void",
      "    flatten(size_type __l, size_type __r, _Iter __first, _Proj __proj = {})",
      "    { for_each(__l, __r, [&](const_reference __ref) -> bool { *__first = std::invoke(__proj, __ref); ++__first; return true; }); }",
      "",
      "",
      "    [[nodiscard]] constexpr value_type",
      "    reduce(size_type __l, size_type __r)",
      "    { return _M_reduce(1, 1, size(), __l + 1, __r + 1); }",
      "",
      "    [[nodiscard]] constexpr value_type",
      "    reduce()",
      "    { return empty() ? value_type{} : reduce(0, size() - 1); }",
      "",
      "    [[nodiscard]] constexpr const_reference",
      "    at(size_type __p)",
      "    { return _M_at(1, 1, size(), __p + 1); }",
      "",
      "    [[nodiscard]] constexpr const_reference",
      "    operator[](size_type __p)",
      "    { return at(__p); }",
      "",
      "    [[nodiscard]] constexpr value_type",
      "    operator[](const std::pair<size_type, size_type>& __p)",
      "    { return reduce(__p.first, __p.second); }",
      "    ",
      "",
      "    [[nodiscard]] constexpr const_reference",
      "    front()",
      "    { return at(0); }",
      "    ",
      "    [[nodiscard]] constexpr const_reference",
      "    back()",
      "    { return at(size() - 1); }",
      "",
      "",
      "    template<typename _Tp, typename _Proj = std::identity>",
      "    requires std::assignable_from<reference, std::invoke_result_t<_Proj, const _Tp&>>",
      "    constexpr void",
      "    set(size_type __l, size_type __r, const _Tp& __value, _Proj __proj = {})",
      "    { for_each(__l, __r, [&](reference __ref) -> bool { __ref = std::invoke(__proj, __value); return true; }); }",
      "",
      "    template<typename _Tp, typename _Proj = std::identity>",
      "    requires std::assignable_from<reference, std::invoke_result_t<_Proj, const _Tp&>>",
      "    constexpr void",
      "    set(size_type __p, const _Tp& __value, _Proj __proj = {})",
      "    { set(__p, __p, __value, __proj); }",
      "",
      "    template<typename _Tp, typename _Proj = std::identity>",
      "    requires std::assignable_from<reference, std::invoke_result_t<_Proj, const _Tp&>>",
      "    constexpr void",
      "    fill(const _Tp& __value, _Proj __proj = {})",
      "    { empty() ? void() : set(0, size() - 1, __value, __proj); }",
      "",
      "    constexpr void",
      "    reset()",
      "    { std::ranges::fill(tree, value_type{}); }",
      "",
      "protected:",
      "",
      "    [[nodiscard]] static constexpr size_type",
      "    ls(size_type __p) noexcept",
      "    { return __p << 1; }",
      "",
      "    [[nodiscard]] static constexpr size_type",
      "    rs(size_type __p) noexcept",
      "    { return __p << 1 | 1; }",
      "",
      "    constexpr void",
      "    push_up(size_type __p)",
      "    { tree[__p] = merge(tree[ls(__p)], tree[rs(__p)]); }",
      "",
      "    virtual void",
      "    push_down(size_type __p, size_type __l, size_type __r)",
      "    { }",
      "",
      "private:",
      "",
      "    template<typename _Callback>",
      "    requires std::invocable<_Callback, reference>",
      "    constexpr bool",
      "    _M_for_each(size_type __p, size_type __l, size_type __r, size_type __x, size_type __y, _Callback&& __func)",
      "    {",
      "        if (__l == __r)",
      "        {",
      "            return __func(tree[__p]);",
      "        }",
      "",
      "        push_down(__p, __l, __r);",
      "",
      "        const size_type mid = __l + __r >> 1;",
      "        bool continues = true;",
      "",
      "        if (__x <= mid)",
      "        {",
      "            continues = _M_for_each(ls(__p), __l, mid, __x, __y, std::forward<_Callback>(__func));",
      "        }",
      "",
      "        if (__y > mid and continues)",
      "        {",
      "            continues = _M_for_each(rs(__p), mid + 1, __r, __x, __y, std::forward<_Callback>(__func));",
      "        }",
      "",
      "        push_up(__p);",
      "",
      "        return continues;",
      "    }",
      "",
      "    template<typename _Callback>",
      "    requires std::invocable<_Callback, reference>",
      "    constexpr bool",
      "    _M_for_each_segment(size_type __p, size_type __l, size_type __r, size_type __x, size_type __y, _Callback&& __func)",
      "    {",
      "        if (__x <= __l and __r <= __y)",
      "        {",
      "            return __func(tree[__p]);",
      "        }",
      "",
      "        push_down(__p, __l, __r);",
      "",
      "        const size_type mid = __l + __r >> 1;",
      "        bool continues = true;",
      "",
      "        if (__x <= mid)",
      "        {",
      "            continues = _M_for_each_segment(ls(__p), __l, mid, __x, __y, std::forward<_Callback>(__func));",
      "        }",
      "",
      "        if (__y > mid and continues)",
      "        {",
      "            continues = _M_for_each_segment(rs(__p), mid + 1, __r, __x, __y, std::forward<_Callback>(__func));",
      "        }",
      "",
      "        return continues;",
      "    }",
      "",
      "    [[nodiscard]] constexpr value_type",
      "    _M_reduce(size_type __p, size_type __l, size_type __r, size_type __x, size_type __y)",
      "    {",
      "        if (__x <= __l and __r <= __y)",
      "        {",
      "            return tree[__p];",
      "        }",
      "",
      "        push_down(__p, __l, __r);",
      "",
      "        const size_type mid = __l + __r >> 1;",
      "",
      "        if (__x <= mid and __y > mid)",
      "        {",
      "            return merge(_M_reduce(ls(__p), __l, mid, __x, __y), _M_reduce(rs(__p), mid + 1, __r, __x, __y));",
      "        }",
      "        else if (__x <= mid)",
      "        {",
      "            return _M_reduce(ls(__p), __l, mid, __x, __y);",
      "        }",
      "        else",
      "        {",
      "            return _M_reduce(rs(__p), mid + 1, __r, __x, __y);",
      "        }",
      "    }",
      "",
      "    [[nodiscard]] constexpr const_reference",
      "    _M_at(size_type __p, size_type __l, size_type __r, size_type __i)",
      "    {",
      "        if (__l == __r)",
      "        {",
      "            return tree[__p];",
      "        }",
      "",
      "        push_down(__p, __l, __r);",
      "",
      "        const size_type mid = __l + __r >> 1;",
      "",
      "        if (__i <= mid)",
      "        {",
      "            return _M_at(ls(__p), __l, mid, __i);",
      "        }",
      "        else",
      "        {",
      "            return _M_at(rs(__p), mid + 1, __r, __i);",
      "        }",
      "    }",
      "",
      "protected:",
      "",
      "    container_type tree;",
      "    _MergeFunc merge;",
      "};",
      "",
      "template<std::input_iterator _Iter, std::sentinel_for<_Iter> _Sent, typename _Proj = std::identity, typename _MergeFunc = std::plus<>>",
      "SegmentTree(_Iter, _Sent, _Proj = {}, _MergeFunc = {}) -> SegmentTree<std::remove_reference_t<std::invoke_result_t<_Proj, std::iter_value_t<_Iter>>>, _MergeFunc>;",
      "",
      "template<std::ranges::input_range _Range, typename _Proj = std::identity, typename _MergeFunc = std::plus<>>",
      "SegmentTree(_Range&&, _Proj = {}, _MergeFunc = {}) -> SegmentTree<std::remove_reference_t<std::invoke_result_t<_Proj, std::ranges::range_value_t<_Range>>>, _MergeFunc>;",
      "}} // namespace huanhuanonly::data_structure"
    ],
    "description": "SegmentTree"
  },

  "problem_metadata_header": {
    "prefix": "problem_metadata_header",
    "body": [
      "/**",
      " * ${1:ContestTitle}",
      " * ",
      " * => ${2:ProblemTitle} ( @c ${3:Rating} )",
      " * ",
      " * -> ${4:ProblemLink}",
      " * ",
      " * Submissions ~> ${5:SubmissionsLink} By huanhuanonly",
      " * ",
      " * @b ${6:AlgorithmLabel}",
      " * ",
      " * ----${CURRENT_MONTH_NAME} ${CURRENT_DATE}, ${CURRENT_YEAR} [${CURRENT_HOUR}h:${CURRENT_MINUTE}m:${CURRENT_SECOND}s]----",
      "*/",
      "",
      "$0"
    ],
    "description": "problem_metadata_header"
  },

  "all [Range from first to last]": {
    "prefix": "all",
    "body": [
      "$1.begin(), $1.end()$0"
    ],
    "description": "all [Range from first to last]"
  },

  "contest_template": {
    "prefix": "contest_template",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "using int8 = signed char;",
      "using int16 = short;",
      "using int32 = int;",
      "using int64 = long long;",
      "",
      "using uint8 = unsigned char;",
      "using uint16 = unsigned short;",
      "using uint32 = unsigned int;",
      "using uint64 = unsigned long long;",
      "",
      "#if defined(__SIZEOF_INT128__)",
      "using int128 = __int128;",
      "using uint128 = unsigned __int128;",
      "#endif",
      "",
      "using real32 = float;",
      "using real64 = double;",
      "",
      "#if defined(__SIZEOF_FLOAT80__)",
      "using real80 = __float80;",
      "#endif",
      "",
      "#if defined(__SIZEOF_FLOAT128__)",
      "using real128 = __float128;",
      "#endif",
      "",
      "int main(void)",
      "{",
      "    std::ios::sync_with_stdio(false);",
      "    std::cin.tie(nullptr);",
      "",
      "    $0",
      "",
      "    return 0;",
      "}"
    ],
    "description": "contest_template"
  },

  "file_header": {
    "prefix": "file_header",
    "body": [
      "/** Copyright (c) 2024 huanhuanonly. All rights reserved.",
      " * ",
      " * @file  ${TM_FILENAME_BASE}",
      " * ",
      " * @brief $1",
      " * ",
      " * Created by Yanghuanhuan (huanhuanonly@gmail.com) on ${CURRENT_DAY_NAME}, ${CURRENT_MONTH_NAME} ${CURRENT_DATE}, ${CURRENT_YEAR} [${CURRENT_HOUR}h:${CURRENT_MINUTE}m:${CURRENT_SECOND}s]",
      " */",
      "",
      "$0"
    ],
    "description": "file_header"
  },

  "fre [IO stream redirection]": {
    "prefix": "fre",
    "body": [
      "#ifdef __huanhuanonly_localhost",
      "    ::freopen(\"in\", \"r\", stdin);",
      "    ::freopen(\"out\", \"w\", stdout);",
      "#endif"
    ],
    "description": "fre [IO stream redirection]"
  },

  "is_prime [miller_rabin]": {
    "prefix": "is_prime",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace math",
      "{",
      "template<typename _Tp>",
      "[[nodiscard]] constexpr bool is_prime(_Tp __n)",
      "{",
      "    constexpr std::array<_Tp, 7> primes{2, 3, 5, 7, 11, 13, 17};",
      "",
      "    if (__n <= 1)",
      "    {",
      "        return false;",
      "    }",
      "",
      "    _Tp t = __n - 1, k = 0;",
      "",
      "    for (; (t & 1) == 0; t >>= 1, ++k);",
      "",
      "    for (_Tp i = 0; i < primes.size(); ++i)",
      "    {",
      "        if (__n == primes[i])",
      "        {",
      "            return true;",
      "        }",
      "",
      "        _Tp x = binary_exponentiation(primes[i], t, __n);",
      "        _Tp next = x;",
      "",
      "        for (_Tp j = 1; j <= k; ++j)",
      "        {",
      "            next = (x * x) % __n;",
      "",
      "            if (next == 1 and x != 1 and x != __n - 1)",
      "            {",
      "                return false;",
      "            }",
      "",
      "            x = next;",
      "        }",
      "",
      "        if (x != 1)",
      "        {",
      "            return false;",
      "        }",
      "    }",
      "",
      "    return true;",
      "}",
      "}} // namespace huanhuanonly::math"
    ],
    "description": "is_prime [miller_rabin]"
  },

  "StaticModular": {
    "prefix": "StaticModular",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace math",
      "{",
      "template<typename _Tp, _Tp _Modulus>",
      "class StaticModular",
      "{",
      "public:",
      "",
      "    using value_type = _Tp;",
      "    using reference = _Tp&;",
      "    using const_reference = const _Tp&;",
      "",
      "    constexpr StaticModular(value_type __value = {}) noexcept",
      "        : _M_value(residue(__value))",
      "    { }",
      "",
      "    constexpr value_type value() const noexcept",
      "    { return _M_value; }",
      "",
      "    static constexpr value_type modulus() noexcept",
      "    { return _Modulus; }",
      "",
      "    template<typename _Ty>",
      "    static constexpr _Ty residue(_Ty __x) noexcept",
      "    {",
      "        if constexpr (std::is_unsigned_v<_Ty>)",
      "        {",
      "            return __x % modulus();",
      "        }",
      "        else",
      "        {",
      "            return (__x % static_cast<_Ty>(modulus()) + static_cast<_Ty>(modulus())) % modulus();",
      "        }",
      "    }",
      "",
      "    template<typename _Ty>",
      "    constexpr StaticModular power(_Ty __x) const noexcept",
      "    {",
      "        StaticModular result(static_cast<value_type>(1));",
      "        auto t = *this;",
      "",
      "        for (; __x; t *= t, __x >>= 1)",
      "        {",
      "            (__x & 1) ? void(result *= t) : void();",
      "        }",
      "",
      "        return result;",
      "    }",
      "",
      "    constexpr StaticModular inverse() const noexcept",
      "    {",
      "        if constexpr (std::is_integral_v<value_type>)",
      "        {",
      "            assert(std::gcd(_M_value, modulus()) == 1);",
      "        }",
      "",
      "        auto extended_euclid = [&](const auto& self, auto a, decltype(a) b) -> std::array<decltype(a), 2>",
      "        {",
      "            if (b == 0)",
      "            {",
      "                return {1, 0};",
      "            }",
      "",
      "            auto [x, y] = self(self, b, a % b);",
      "            return {{y, x - a / b * y}};",
      "        };",
      "",
      "        if constexpr (std::is_signed_v<value_type>)",
      "        {",
      "            return static_cast<value_type>(residue(extended_euclid(extended_euclid, _M_value, modulus())[0]));",
      "        }",
      "        else if constexpr (std::is_unsigned_v<value_type>)",
      "        {",
      "            return static_cast<value_type>(residue(extended_euclid(extended_euclid, std::make_signed_t<value_type>(_M_value), std::make_signed_t<value_type>(modulus()))[0]));",
      "        }",
      "        else",
      "        {",
      "            return static_cast<value_type>(residue(extended_euclid(extended_euclid, __int128_t(_M_value), __int128_t(modulus()))[0]));",
      "        }",
      "    }",
      "",
      "    template<typename _Ty>",
      "    constexpr _Ty cast() const noexcept",
      "    { return static_cast<_Ty>(_M_value); }",
      "",
      "",
      "    constexpr StaticModular& operator=(value_type __value) noexcept",
      "    { _M_value = residue(__value); return *this; }",
      "",
      "    constexpr operator value_type() const noexcept",
      "    { return _M_value; }",
      "",
      "    constexpr std::strong_ordering operator<=>(value_type __x) const noexcept",
      "    { return _M_value <=> __x; }",
      "",
      "    constexpr std::strong_ordering operator<=>(StaticModular __other) const noexcept",
      "    { return _M_value <=> __other._M_value; }",
      "",
      "    constexpr reference operator*() noexcept",
      "    { return _M_value; }",
      "    ",
      "    constexpr const_reference operator*() const noexcept",
      "    { return _M_value; }",
      "",
      "    constexpr bool operator!() const noexcept",
      "    { return !_M_value; }",
      "",
      "    constexpr StaticModular operator~() const noexcept",
      "    { return ~_M_value; }",
      "",
      "    constexpr StaticModular operator+() const noexcept",
      "    { return +_M_value; }",
      "",
      "    constexpr StaticModular operator-() const noexcept",
      "    { return -_M_value; }",
      "",
      "    constexpr StaticModular& operator++() noexcept",
      "    { _M_value = residue(++_M_value); return *this; }",
      "",
      "    constexpr StaticModular& operator--() noexcept",
      "    { _M_value -= 1; return *this; }",
      "",
      "    constexpr StaticModular operator++(int) noexcept",
      "    { auto t = *this; ++*this; return t; }",
      "",
      "    constexpr StaticModular operator--(int) noexcept",
      "    { auto t = *this; --*this; return t; }",
      "",
      "    constexpr StaticModular operator+(value_type __x) const noexcept",
      "    { return _M_value + residue(__x); }",
      "",
      "    constexpr StaticModular operator-(value_type __x) const noexcept",
      "    { return _M_value + modulus() - residue(__x); }",
      "    ",
      "    constexpr StaticModular operator*(value_type __x) const noexcept",
      "    { auto t = *this; t *= __x; return t; }",
      "",
      "    constexpr StaticModular operator/(value_type __x) const noexcept",
      "    { return *this * StaticModular(__x).inverse(); }",
      "",
      "    constexpr StaticModular operator%(value_type __x) const noexcept",
      "    { return _M_value % __x; }",
      "",
      "    constexpr StaticModular& operator+=(value_type __x) noexcept",
      "    { return *this = *this + __x; }",
      "    ",
      "    constexpr StaticModular& operator-=(value_type __x) noexcept",
      "    { return *this = *this - __x; }",
      "",
      "    constexpr StaticModular& operator*=(value_type __x) noexcept",
      "    {",
      "        if constexpr (std::numeric_limits<value_type>::max() / modulus() >= modulus())",
      "        {",
      "            _M_value = residue(_M_value * residue(__x));",
      "            return *this;",
      "        }",
      "#if defined(__SIZEOF_INT128__)",
      "        else if constexpr (sizeof(value_type) <= 8U)",
      "        {",
      "            _M_value = static_cast<value_type>(residue(static_cast<__uint128_t>(_M_value) * residue(__x)));",
      "            return *this;",
      "        }",
      "#endif",
      "        else",
      "        {",
      "            __x = residue(__x);",
      "    ",
      "            StaticModular result;",
      "    ",
      "            for (; __x; *this += *this, __x >>= 1)",
      "            {",
      "                (__x & 1) ? void(result += *this) : void();",
      "            }",
      "    ",
      "            return *this = result;",
      "        }",
      "    }",
      "",
      "    constexpr StaticModular& operator/=(value_type __x) noexcept",
      "    { return *this = *this / __x; }",
      "",
      "    constexpr StaticModular& operator%=(value_type __x) noexcept",
      "    { return *this = *this % __x; }",
      "",
      "    constexpr StaticModular operator<<(value_type __x) const noexcept",
      "    { return *this * StaticModular(2).power(__x); }",
      "",
      "    constexpr StaticModular operator>>(value_type __x) const noexcept",
      "    { return *this / StaticModular(2).power(__x); }",
      "",
      "    constexpr StaticModular& operator<<=(value_type __x) noexcept",
      "    { return *this *= StaticModular(2).power(__x); }",
      "",
      "    constexpr StaticModular& operator>>=(value_type __x) noexcept",
      "    { return *this /= StaticModular(2).power(__x); }",
      "",
      "    constexpr StaticModular operator^(value_type __x) const noexcept",
      "    { return _M_value ^ __x; }",
      "",
      "    constexpr StaticModular operator&(value_type __x) const noexcept",
      "    { return _M_value & __x; }",
      "",
      "    constexpr StaticModular operator|(value_type __x) const noexcept",
      "    { return _M_value | __x; }",
      "",
      "    constexpr StaticModular& operator^=(value_type __x) noexcept",
      "    { return *this = *this ^ __x; }",
      "",
      "    constexpr StaticModular& operator&=(value_type __x) noexcept",
      "    { return *this = *this & __x; }",
      "",
      "    constexpr StaticModular& operator|=(value_type __x) noexcept",
      "    { return *this = *this | __x; }",
      "",
      "    friend inline std::istream& operator>>(std::istream& __is, StaticModular& __that) noexcept",
      "    { auto& result = __is >> __that._M_value; __that._M_value = __that.residue(__that._M_value); return result; }",
      "",
      "    friend inline std::ostream& operator<<(std::ostream& __os, const StaticModular& __that) noexcept",
      "    { return __os << __that._M_value; }",
      "",
      "private:",
      "",
      "    value_type _M_value;",
      "};",
      "}} // namespace huanhuanonly::math"
    ],
    "description": "StaticModular"
  },

  "primes_in_range": {
    "prefix": "primes_in_range",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace math",
      "{",
      "template<typename _Container = std::vector<int>>",
      "[[nodiscard]] constexpr _Container primes_in_range(std::size_t __n)",
      "{",
      "    _Container primes;",
      "",
      "    std::vector<bool> vis(__n + 1);",
      "",
      "    vis[0] = vis[1] = true;",
      "",
      "    for (std::size_t i = 2; i <= __n; ++i)",
      "    {",
      "        if (not vis[i])",
      "        {",
      "            primes.push_back(static_cast<_Container::value_type>(i));",
      "        }",
      "",
      "        for (const auto p : primes | std::views::take_while([__n, i](auto p) -> bool { return i * p <= __n; }))",
      "        {",
      "            vis[i * p] = true;",
      "",
      "            if (i % p == 0)",
      "            {",
      "                break;",
      "            }",
      "        }",
      "    }",
      "",
      "    return primes;",
      "}",
      "}} // namespace huanhuanonly::math"
    ],
    "description": "primes_in_range"
  },

  "XorBasis": {
    "prefix": "XorBasis",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace math",
      "{",
      "template<typename _Tp, typename _St = std::size_t, _St _Size = sizeof(_Tp) * 8>",
      "requires requires(_Tp __x, _St __n) {",
      "    {__x ^ __x} -> std::same_as<_Tp>;",
      "    {__x & __x} -> std::same_as<_Tp>;",
      "    {__x >> __n} -> std::same_as<_Tp>;",
      "    {__x == __x} -> std::same_as<bool>;",
      "    {__x ^= __x} -> std::same_as<_Tp&>; }",
      "class XorBasis",
      "{",
      "public:",
      "",
      "    using value_type = _Tp;",
      "    using size_type  = _St;",
      "",
      "    constexpr",
      "    XorBasis() noexcept",
      "        : _M_basis{}, _M_size(0), _M_zero(false)",
      "    { }",
      "",
      "    template<std::input_iterator _Iter, std::sentinel_for<_Iter> _Sent, typename _Proj = std::identity>",
      "    constexpr",
      "    XorBasis(_Iter __first, _Sent __last, _Proj __proj = {}) noexcept",
      "        : XorBasis()",
      "    { insert(__first, __last, __proj); }",
      "",
      "    template<std::ranges::input_range _Range, typename _Proj = std::identity>",
      "    constexpr",
      "    XorBasis(_Range&& __r, _Proj __proj = {}) noexcept",
      "        : XorBasis()",
      "    { insert(std::forward<_Range>(__r), __proj); }",
      "",
      "    constexpr",
      "    XorBasis(std::initializer_list<value_type> __list) noexcept",
      "        : XorBasis()",
      "    { insert(__list); }",
      "",
      "",
      "    [[nodiscard]] constexpr bool",
      "    operator==(const XorBasis& __other) const noexcept",
      "    { return _M_zero == __other._M_zero and std::ranges::equal(_M_basis, __other._M_basis, {}, _S_check); }",
      "",
      "    [[nodiscard]] constexpr bool",
      "    operator!=(const XorBasis& __other) const noexcept",
      "    { return not (*this == __other); }",
      "",
      "",
      "    [[nodiscard]] static constexpr size_type",
      "    bit_count() noexcept",
      "    { return _Size; }",
      "",
      "    [[nodiscard]] constexpr size_type",
      "    size() const noexcept",
      "    { return _M_size; }",
      "",
      "    [[nodiscard]] constexpr bool",
      "    empty() const noexcept",
      "    { return _M_size == size_type{} and _M_zero == false; }",
      "",
      "    [[nodiscard]] constexpr bool",
      "    operator not() const noexcept",
      "    { return empty(); }",
      "    ",
      "    [[nodiscard]] constexpr",
      "    operator bool() const noexcept",
      "    { return not empty(); }",
      "",
      "    [[nodiscard]] constexpr size_type",
      "    count() const noexcept",
      "    { return (1 << _M_size) - not _M_zero; }",
      "",
      "    [[nodiscard]] constexpr auto",
      "    view() const noexcept",
      "    { return _M_basis | std::views::filter([](value_type i) -> bool { return static_cast<bool>(i); }); }",
      "",
      "    constexpr void",
      "    clear() noexcept",
      "    {",
      "        _M_basis.fill(value_type{});",
      "        _M_size = size_type{};",
      "        _M_zero = false;",
      "    }",
      "",
      "    constexpr bool",
      "    insert(value_type __value) noexcept",
      "    {",
      "        for (size_type i = static_cast<size_type>(_M_basis.size()); i--; )",
      "        {",
      "            if (_S_take(__value, i))",
      "            {",
      "                if (_S_check(_M_basis[i]))",
      "                {",
      "                    __value ^= _M_basis[i];",
      "                }",
      "                else",
      "                {",
      "                    _M_basis[i] = __value;",
      "                    ++_M_size;",
      "                    return true;",
      "                }",
      "            }",
      "        }",
      "",
      "        _M_zero = true;",
      "        return false;",
      "    }",
      "",
      "    template<std::input_iterator _Iter, std::sentinel_for<_Iter> _Sent, typename _Proj = std::identity>",
      "    constexpr size_type",
      "    insert(_Iter __first, _Sent __last, _Proj __proj = {}) noexcept",
      "    {",
      "        size_type n{};",
      "",
      "        for (; __first != __last; ++__first)",
      "        {",
      "            n += insert(std::invoke(__proj, *__first));",
      "        }",
      "",
      "        return n;",
      "    }",
      "",
      "    template<std::ranges::input_range _Range, typename _Proj = std::identity>",
      "    constexpr size_type",
      "    insert(_Range&& __r, _Proj __proj = {})",
      "    { return insert(std::ranges::begin(__r), std::ranges::end(__r), __proj); }",
      "",
      "    constexpr void",
      "    normalize() noexcept",
      "    {",
      "        for (size_type i = static_cast<size_type>(_M_basis.size()); i--; )",
      "        {",
      "            if (_S_check(_M_basis[i]))",
      "            {",
      "                for (size_type j = i; j--; )",
      "                {",
      "                    if (_S_check(_M_basis[j]))",
      "                    {",
      "                        _M_basis[i] ^= _M_basis[j];",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "",
      "    [[nodiscard]] constexpr bool",
      "    contains(value_type __value) const noexcept",
      "    {",
      "        if (not _S_check(__value))",
      "        {",
      "            return _M_zero;",
      "        }",
      "",
      "        for (size_type i = static_cast<size_type>(_M_basis.size()); i--; )",
      "        {",
      "            if (_S_take(__value, i))",
      "            {",
      "                if (_S_check(_M_basis[i]))",
      "                {",
      "                    __value ^= _M_basis[i];",
      "                }",
      "                else",
      "                {",
      "                    return false;",
      "                }",
      "            }",
      "        }",
      "",
      "        return true;",
      "    }",
      "",
      "    [[nodiscard]] constexpr value_type",
      "    find_min_xor_sum() const noexcept",
      "    { return _M_zero ? value_type{} : *std::ranges::find(_M_basis, true, _S_check); }",
      "",
      "    [[nodiscard]] constexpr value_type",
      "    find_max_xor_sum() const noexcept",
      "    {",
      "        value_type max{};",
      "",
      "        for (size_type i = static_cast<size_type>(_M_basis.size()); i--; )",
      "        {",
      "            if (_S_check(_M_basis[i]) and not _S_take(max, i))",
      "            {",
      "                max ^= _M_basis[i];",
      "            }",
      "        }",
      "",
      "        return max;",
      "    }",
      "",
      "    [[nodiscard]] constexpr value_type",
      "    find_kth_smallest(size_type __k) const noexcept",
      "    {",
      "        assert(__k >= 0 and __k < count());",
      "",
      "        if (_M_zero)",
      "        {",
      "            if (__k == 0)",
      "            {",
      "                return value_type{};",
      "            }",
      "        }",
      "        else",
      "        {",
      "            ++__k;",
      "        }",
      "",
      "        value_type result{};",
      "        size_type  cnt = 1 << _M_size - 1;",
      "",
      "        for (size_type i = static_cast<size_type>(_M_basis.size()); i--; )",
      "        {",
      "            if (_S_check(_M_basis[i]))",
      "            {",
      "                if (__k >= cnt)",
      "                {",
      "                    if (not _S_take(result, i))",
      "                    {",
      "                        result ^= _M_basis[i];",
      "                    }",
      "                    ",
      "                    __k -= cnt;",
      "                }",
      "                else if (_S_take(result, i))",
      "                {",
      "                    result ^= _M_basis[i];",
      "                }",
      "",
      "                cnt >>= 1;",
      "            }",
      "        }",
      "",
      "        return result;",
      "    }",
      "",
      "    [[nodiscard]] constexpr value_type",
      "    find_kth_largest(size_type __k) const noexcept",
      "    {",
      "        assert(count() >= 1 + __k);",
      "        return find_kth_smallest(count() - 1 - __k);",
      "    }",
      "",
      "    [[nodiscard]] constexpr value_type",
      "    find_kth_smallest_after_normalization(size_type __k) const noexcept",
      "    {",
      "        assert(__k >= 0 and __k < count());",
      "",
      "        if (_M_zero)",
      "        {",
      "            if (__k == 0)",
      "            {",
      "                return value_type{};",
      "            }",
      "        }",
      "        else",
      "        {",
      "            ++__k;",
      "        }",
      "",
      "        value_type result{};",
      "",
      "        for (size_type i = 0; i < static_cast<size_type>(_M_basis.size()); ++i)",
      "        {",
      "            if (_S_check(_M_basis[i]))",
      "            {",
      "                if (__k & 1)",
      "                {",
      "                    result ^= _M_basis[i];",
      "                }",
      "",
      "                __k >>= 1;",
      "            }",
      "        }",
      "",
      "        return result;",
      "    }",
      "",
      "    [[nodiscard]] constexpr value_type",
      "    find_kth_largest_after_normalization(size_type __k) const noexcept",
      "    {",
      "        assert(count() >= 1 + __k);",
      "        return find_kth_smallest_after_normalization(count() - 1 - __k);",
      "    }",
      "",
      "    [[nodiscard]] constexpr size_type",
      "    count_le(const value_type& __value) const noexcept",
      "    {",
      "        if (__value <= 0)",
      "        {",
      "            return size_type{};",
      "        }",
      "        else if (_M_size == 0)",
      "        {",
      "            return _M_zero;",
      "        }",
      "",
      "        value_type result{};",
      "        size_type cnt = 1 << _M_size - 1;",
      "",
      "        value_type mask{};",
      "",
      "        for (size_type i = static_cast<size_type>(_M_basis.size()); i--; )",
      "        {",
      "            if (_S_check(_M_basis[i]))",
      "            {",
      "                if (_S_take(__value, i))",
      "                {",
      "                    result += cnt;",
      "",
      "                    if (not _S_take(mask, i))",
      "                    {",
      "                        mask ^= _M_basis[i];",
      "                    }",
      "                }",
      "                else if (_S_take(mask, i))",
      "                {",
      "                    mask ^= _M_basis[i];",
      "                }",
      "",
      "                cnt >>= 1;",
      "            }",
      "            else if (const auto lb = _S_take(__value, i), rb = _S_take(mask, i); lb != rb)",
      "            {",
      "                if (lb)",
      "                {",
      "                    result += cnt << 1;",
      "                }",
      "",
      "                break;",
      "            }",
      "        }",
      "",
      "        return result - not _M_zero;",
      "    }",
      "",
      "    [[nodiscard]] constexpr size_type",
      "    count_leq(const value_type& __value) const noexcept",
      "    { return count_le(__value) + contains(__value); }",
      "",
      "    [[nodiscard]] constexpr size_type",
      "    count_ge(const value_type& __value) const noexcept",
      "    { return count() - count_leq(__value); }",
      "",
      "    [[nodiscard]] constexpr size_type",
      "    count_geq(const value_type& __value) const noexcept",
      "    { return count() - count_le(__value); }",
      "",
      "",
      "    [[nodiscard]] constexpr std::optional<value_type>",
      "    prev_less(const value_type& __value, size_type __n = 1) const noexcept",
      "    {",
      "        if (__n == 0) [[unlikely]]",
      "        {",
      "            if (contains(__value))",
      "            {",
      "                return __value;",
      "            }",
      "            else",
      "            {",
      "                return std::nullopt;",
      "            }",
      "        }",
      "",
      "        if (const size_type cid = count_le(__value); cid >= __n) [[likely]]",
      "        {",
      "            return find_kth_smallest(cid - __n);",
      "        }",
      "        else [[unlikely]]",
      "        {",
      "            return std::nullopt;",
      "        }",
      "    }",
      "",
      "    [[nodiscard]] constexpr std::optional<value_type>",
      "    next_greater(const value_type& __value, size_type __n = 1) const noexcept",
      "    {",
      "        if (__n == 0) [[unlikely]]",
      "        {",
      "            if (contains(__value))",
      "            {",
      "                return __value;",
      "            }",
      "            else",
      "            {",
      "                return std::nullopt;",
      "            }",
      "        }",
      "",
      "        if (const size_type cid = count_ge(__value); cid >= __n) [[likely]]",
      "        {",
      "            return find_kth_largest(cid - __n);",
      "        }",
      "        else [[unlikely]]",
      "        {",
      "            return std::nullopt;",
      "        }",
      "    }",
      "",
      "    [[nodiscard]] constexpr value_type",
      "    operator[](std::make_signed_t<size_type> __n) const noexcept",
      "    { return __n >= 0 ? find_kth_smallest(size_type(__n)) : find_kth_largest(size_type(-__n - 1)); }",
      "",
      "",
      "    constexpr void",
      "    merge(const XorBasis& __other) noexcept",
      "    {",
      "        for (size_type i = 0; i < static_cast<size_type>(_M_basis.size()); ++i)",
      "        {",
      "            if (_S_check(__other._M_basis[i]))",
      "            {",
      "                insert(__other._M_basis[i]);",
      "            }",
      "        }",
      "",
      "        if (__other._M_zero)",
      "        {",
      "            _M_zero = true;",
      "        }",
      "    }",
      "",
      "    constexpr XorBasis&",
      "    operator|=(const XorBasis& __other) noexcept",
      "    { return merge(__other), *this; }",
      "",
      "    [[nodiscard]] constexpr XorBasis",
      "    operator|(const XorBasis& __other) const noexcept",
      "    { return XorBasis(*this) |= __other; }",
      "",
      "protected:",
      "",
      "    [[nodiscard]] static constexpr bool",
      "    _S_check(const value_type& __value) noexcept",
      "    {",
      "        if constexpr (std::convertible_to<value_type, bool>)",
      "        {",
      "            return static_cast<bool>(__value);",
      "        }",
      "        else",
      "        {",
      "            return not (__value == value_type{});",
      "        }",
      "    }",
      "",
      "    [[nodiscard]] static constexpr bool",
      "    _S_take(const value_type& __value, size_type __i) noexcept",
      "    {",
      "        if constexpr (requires{ {__value[__i] } -> std::convertible_to<bool>; })",
      "        {",
      "            return __value[__i];",
      "        }",
      "        else",
      "        {",
      "            return __value >> __i & 1;",
      "        }",
      "    }",
      "",
      "private:",
      "",
      "    std::array<value_type, bit_count()> _M_basis;",
      "    size_type _M_size;",
      "    bool _M_zero;",
      "};",
      "",
      "template<std::input_iterator _Iter, std::sentinel_for<_Iter> _Sent, typename _Proj = std::identity>",
      "XorBasis(_Iter, _Sent, _Proj = {}) -> XorBasis<std::remove_reference_t<std::invoke_result_t<_Proj, std::iter_reference_t<_Iter>>>>;",
      "",
      "template<std::ranges::input_range _Range, typename _Proj = std::identity>",
      "XorBasis(_Range&&, _Proj = {}) -> XorBasis<std::remove_reference_t<std::invoke_result_t<_Proj, std::iter_reference_t<decltype(std::ranges::begin(std::declval<_Range>()))>>>>;",
      "",
      "template<std::size_t _Size>",
      "[[nodiscard]] constexpr std::strong_ordering",
      "operator<=>(const std::bitset<_Size>& __lhs, const std::bitset<_Size>& __rhs) noexcept",
      "{",
      "    constexpr auto n = sizeof(std::bitset<_Size>);",
      "",
      "    if constexpr (n % sizeof(std::uint64_t) == 0)",
      "    {",
      "        constexpr auto c = n / sizeof(std::uint64_t);",
      "",
      "        auto lptr = reinterpret_cast<const std::uint64_t*>(&__lhs) + c - 1;",
      "        auto rptr = reinterpret_cast<const std::uint64_t*>(&__rhs) + c - 1;",
      "",
      "        for (auto i = 0; i < c; ++i, --lptr, --rptr)",
      "        {",
      "            if (*lptr != *rptr)",
      "            {",
      "                return *lptr < *rptr ? std::strong_ordering::less : std::strong_ordering::greater;",
      "            }",
      "        }",
      "    }",
      "    else",
      "    {",
      "        constexpr auto c = n / sizeof(std::uint32_t);",
      "",
      "        auto lptr = reinterpret_cast<const std::uint32_t*>(&__lhs) + c - 1;",
      "        auto rptr = reinterpret_cast<const std::uint32_t*>(&__rhs) + c - 1;",
      "",
      "        for (auto i = 0; i < c; ++i, --lptr, --rptr)",
      "        {",
      "            if (*lptr != *rptr)",
      "            {",
      "                return *lptr < *rptr ? std::strong_ordering::less : std::strong_ordering::greater;",
      "            }",
      "        }",
      "    }",
      "",
      "    return std::strong_ordering::equivalent;",
      "}",
      "}} // namespace huanhuanonly::math"
    ],
    "description": "XorBasis"
  },

  "euler_phi": {
    "prefix": "euler_phi",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace math",
      "{",
      "template<typename _Tp>",
      "[[nodiscard]] _Tp euler_phi(_Tp __n)",
      "{",
      "    _Tp result = __n;",
      "    for (_Tp i = 2; i * i <= __n; ++i)",
      "    {",
      "        if (__n % i == 0)",
      "        {",
      "            for (; __n % i == 0; __n /= i);",
      "            result -= result / i;",
      "        }",
      "    }",
      "",
      "    if (__n > 1)",
      "    {",
      "        result -= result / __n;",
      "    }",
      "",
      "    return result;",
      "}",
      "}} // namespace huanhuanonly::math"
    ],
    "description": "euler_phi"
  },

  "prime_factorization": {
    "prefix": "prime_factorization",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace math",
      "{",
      "template<typename _Tp>",
      "[[nodiscard]] std::vector<_Tp> prime_factorization(_Tp __n)",
      "{",
      "    std::vector<_Tp> res;",
      "",
      "    for (_Tp i = 2; i * i <= __n; ++i)",
      "    {",
      "        for (; __n % i == 0; __n /= i)",
      "        {",
      "            res.push_back(i);",
      "        }",
      "    }",
      "",
      "    if (__n != 1)",
      "    {",
      "        res.push_back(__n);",
      "    }",
      "",
      "    return res;",
      "}",
      "}} // namespace huanhuanonly::math"
    ],
    "description": "prime_factorization"
  },

  "is_prime": {
    "prefix": "is_prime",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace math",
      "{",
      "template<typename _Tp>",
      "[[nodiscard]] constexpr bool is_prime(_Tp __n)",
      "{",
      "    if (__n <= 3)",
      "    {",
      "        return __n > 1;",
      "    }",
      "    else if (__n % 6 != 1 and __n % 6 != 5)",
      "    {",
      "        return false;",
      "    }",
      "",
      "    for (_Tp i = 5; i * i <= __n; i += 6)",
      "    {",
      "        if (__n % i == 0 or __n % (i + 2) == 0)",
      "        {",
      "            return false;",
      "        }",
      "    }",
      "",
      "    return true;",
      "}",
      "}} // namespace huanhuanonly::math"
    ],
    "description": "is_prime"
  },

  "binary_exponentiation": {
    "prefix": "binary_exponentiation",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace math",
      "{",
      "template<typename _Tp>",
      "[[nodiscard]] constexpr _Tp binary_exponentiation(_Tp __lhs, _Tp __rhs, _Tp __mod)",
      "{",
      "    auto res = static_cast<_Tp>(1);",
      "",
      "    for (__lhs %= __mod; __rhs; __lhs = (__lhs * __lhs) % __mod, __rhs >>= 1)",
      "    {",
      "        if (__rhs & 1)",
      "        {",
      "            res = (res * __lhs) % __mod;",
      "        }",
      "    }",
      "",
      "    return res;",
      "}",
      "}} // namespace huanhuanonly::math"
    ],
    "description": "binary_exponentiation"
  },

  "exgcd": {
    "prefix": "exgcd",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace math",
      "{",
      "template<typename _Tp>",
      "[[nodiscard]] constexpr _Tp exgcd(_Tp __a, _Tp& __x, _Tp __b, _Tp& __y)",
      "{",
      "    if (__b)",
      "    {",
      "        _Tp nx, ny;",
      "        const _Tp gcd = exgcd(__b, nx, __a % __b, ny);",
      "        ",
      "        __x = ny;",
      "        __y = nx - __a / __b * ny;",
      "        ",
      "        return gcd;",
      "    }",
      "    else",
      "    {",
      "        __x = 1, __y = 0;",
      "        return __a;",
      "    }",
      "}",
      "}} // namespace huanhuanonly::math"
    ],
    "description": "exgcd"
  },

  "Fraction": {
    "prefix": "Fraction",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace math",
      "{",
      "template<typename _Tp>",
      "struct Fraction",
      "{",
      "    using value_type = _Tp;",
      "",
      "    mutable value_type numerator = 0;",
      "    mutable value_type denominator = 1;",
      "",
      "    constexpr Fraction() noexcept = default;",
      "",
      "    constexpr Fraction(value_type numerator, value_type denominator = 1) noexcept",
      "        : numerator(numerator), denominator(denominator)",
      "    { simplify(); }",
      "",
      "    template<typename _Ty>",
      "    constexpr Fraction(const Fraction<_Ty>& other) noexcept",
      "        : numerator(static_cast<value_type>(other.numerator)), denominator(static_cast<value_type>(other.denominator))",
      "    { }",
      "",
      "    constexpr Fraction reciprocal() const noexcept",
      "    { return Fraction(denominator, numerator); }",
      "",
      "    static constexpr void unify(const Fraction& first, const Fraction& second) noexcept",
      "    {",
      "#if true",
      "        first.numerator *= second.denominator;",
      "        second.numerator *= first.denominator;",
      "",
      "        first.denominator = second.denominator = first.denominator * second.denominator;",
      "#else",
      "        const auto lcm = std::lcm(first.denominator, second.denominator);",
      "",
      "        first.numerator *= lcm;",
      "        second.numerator *= lcm;",
      "",
      "        first.denominator = second.denominator = lcm;",
      "#endif",
      "    }",
      "",
      "    static constexpr void simplify(const Fraction& that) noexcept",
      "    {",
      "        const auto gcd = std::gcd(that.numerator, that.denominator);",
      "",
      "        that.numerator /= gcd;",
      "        that.denominator /= gcd;",
      "    }",
      "",
      "    constexpr Fraction& simplify() noexcept",
      "    { simplify(*this); return *this; }",
      "",
      "    constexpr const Fraction& simplify() const noexcept",
      "    { simplify(*this); return *this; }",
      "",
      "    /**",
      "     * @returns Fraction(1) - *this.",
      "     */",
      "    constexpr Fraction operator~() const noexcept",
      "    { return Fraction(denominator - numerator, denominator); }",
      "",
      "    constexpr Fraction operator-() const noexcept",
      "    { return Fraction(-numerator, denominator); }",
      "",
      "    constexpr Fraction operator+() const noexcept",
      "    { return *this; }",
      "",
      "    constexpr std::strong_ordering operator<=>(const Fraction& other) const noexcept",
      "    {",
      "        unify(*this, other);",
      "        auto result = numerator <=> other.numerator;",
      "",
      "        simplify(), other.simplify();",
      "        return result;",
      "    }",
      "",
      "    constexpr operator bool() const noexcept",
      "    { return *this != 0; }",
      "",
      "    constexpr bool operator!() const noexcept",
      "    { return *this == 0; }",
      "",
      "    constexpr Fraction& operator+=(const Fraction& other) noexcept",
      "    {",
      "        unify(*this, other);",
      "        numerator += other.numerator;",
      "",
      "        simplify(), other.simplify();",
      "        return *this;",
      "    }",
      "",
      "    constexpr Fraction& operator-=(const Fraction& other) noexcept",
      "    {",
      "        unify(*this, other);",
      "        numerator -= other.numerator;",
      "",
      "        simplify(), other.simplify();",
      "        return *this;",
      "    }",
      "",
      "    constexpr Fraction& operator*=(const Fraction& other) noexcept",
      "    {",
      "        numerator *= other.numerator;",
      "        denominator *= other.denominator;",
      "",
      "        simplify();",
      "        return *this;",
      "    }",
      "",
      "    constexpr Fraction& operator/=(const Fraction& other) noexcept",
      "    { return *this *= other.reciprocal(); }",
      "",
      "    constexpr Fraction& operator++() noexcept",
      "    {",
      "        ++numerator;",
      "",
      "        simplify();",
      "        return *this;",
      "    }",
      "",
      "    constexpr Fraction& operator--() noexcept",
      "    {",
      "        --numerator;",
      "        ",
      "        simplify();",
      "        return *this;",
      "    }",
      "",
      "    constexpr Fraction operator++(int) noexcept",
      "    { auto t = *this; ++*this; return t; }",
      "",
      "    constexpr Fraction operator--(int) noexcept",
      "    { auto t = *this; --*this; return t; }",
      "",
      "    constexpr Fraction operator+(const Fraction& other) const noexcept",
      "    { auto t = *this; return t += other; }",
      "",
      "    constexpr Fraction operator-(const Fraction& other) const noexcept",
      "    { auto t = *this; return t -= other; }",
      "",
      "    constexpr Fraction operator*(const Fraction& other) const noexcept",
      "    { auto t = *this; return t *= other; }",
      "",
      "    constexpr Fraction operator/(const Fraction& other) const noexcept",
      "    { auto t = *this; return t /= other; }",
      "",
      "    template<typename _Ty>",
      "    constexpr _Ty cast() const noexcept",
      "    { return static_cast<_Ty>(numerator) / denominator; }",
      "",
      "    template<typename _Ty>",
      "    constexpr _Ty cast(_Ty mod) const noexcept",
      "    { return _Ty(numerator) * binary_exponentiation(_Ty(denominator), mod - 2, mod) % mod; }",
      "};",
      "",
      "template<typename _Tp>",
      "constexpr auto make_fraction(_Tp numerator, _Tp denominator = 1)",
      "{ return Fraction<_Tp>(numerator, denominator); }",
      "}} // namespace huanhuanonly::math"
    ],
    "description": "Fraction"
  },

  "binary_multiplication": {
    "prefix": "binary_multiplication",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace math",
      "{",
      "template<typename _Tp>",
      "[[nodiscard]] constexpr _Tp binary_multiplication(_Tp __lhs, _Tp __rhs, _Tp __mod)",
      "{",
      "    auto res = static_cast<_Tp>(0);",
      "    ",
      "    for (__lhs %= __mod, __rhs %= __mod; __rhs; __lhs = (__lhs + __lhs) % __mod, __rhs >>= 1)",
      "    {",
      "        if (__rhs & 1)",
      "        {",
      "            res = (res + __lhs) % __mod;",
      "        }",
      "    }",
      "",
      "    return res;",
      "}",
      "}} // namespace huanhuanonly::math"
    ],
    "description": "binary_multiplication"
  },

  "Matrix": {
    "prefix": "Matrix",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace math",
      "{",
      "template<typename _Tp, uint32 _RowCount, uint32 _ColumnCount>",
      "class Matrix",
      "{",
      "public:",
      "    ",
      "    using value_type = _Tp;",
      "    using pointer = _Tp*;",
      "    using const_pointer = const _Tp*;",
      "    using reference = _Tp&;",
      "    using const_reference = const _Tp&;",
      "",
      "    // Do nothing",
      "    Matrix(std::nullptr_t) noexcept",
      "    { }",
      "",
      "    Matrix(_Tp __value = _Tp{}) noexcept : Matrix(nullptr)",
      "    { fill(__value); }",
      "",
      "    template<typename _Generator = _Tp (*)(uint32, uint32)>",
      "    Matrix(_Generator __er) : Matrix(nullptr)",
      "    { fill(__er); }",
      "",
      "    Matrix(std::initializer_list<std::initializer_list<value_type>> __init) : Matrix(nullptr)",
      "    {",
      "        for_each([this, &__init](uint32 i, uint32 j) -> void",
      "        {",
      "            _M_matrix[i][j] = (",
      "                i < __init.size() and j < (__init.begin() + i)->size()",
      "                ? *((__init.begin() + i)->begin() + j)",
      "                : value_type(0));",
      "        });",
      "    }",
      "",
      "    void fill(value_type __value) noexcept",
      "    {",
      "        for_each([this, &__value](uint32 i, uint32 j) -> void",
      "        {",
      "            _M_matrix[i][j] = __value;",
      "        });",
      "    }",
      "",
      "    template<typename _Generator = value_type (*)(uint32, uint32)>",
      "    void fill(_Generator __er)",
      "    {",
      "        for_each([this, &__er](uint32 i, uint32 j) -> void",
      "        {",
      "            _M_matrix[i][j] = __er(i, j);",
      "        });",
      "    }",
      "",
      "    Matrix operator+(const Matrix& __it) const noexcept",
      "    {",
      "        Matrix res(nullptr);",
      "",
      "        for_each([this, &__it, &res](uint32 i, uint32 j) -> void",
      "        {",
      "            res[i][j] = _M_matrix[i][j] + __it._M_matrix[i][j];",
      "        });",
      "",
      "        return res;",
      "    }",
      "",
      "    Matrix& operator+=(const Matrix& __it) noexcept",
      "    {",
      "        for_each([this, &__it](uint32 i, uint32 j) -> void",
      "        {",
      "            _M_matrix[i][j] += __it._M_matrix[i][j];",
      "        });",
      "    }",
      "",
      "    Matrix operator-(const Matrix& __it) const noexcept",
      "    {",
      "        Matrix res(nullptr);",
      "",
      "        for_each([this, &__it, &res](uint32 i, uint32 j) -> void",
      "        {",
      "            res[i][j] = _M_matrix[i][j] - __it._M_matrix[i][j];",
      "        });",
      "",
      "        return res;",
      "    }",
      "",
      "    Matrix& operator-=(const Matrix& __it) noexcept",
      "    {",
      "        for_each([this, &__it](uint32 i, uint32 j) -> void",
      "        {",
      "            _M_matrix[i][j] -= __it._M_matrix[i][j];",
      "        });",
      "    }",
      "",
      "    template<uint32 _ItsColumnCount>",
      "    Matrix operator*(const Matrix<_Tp, _ColumnCount, _ItsColumnCount>& __it) const",
      "    {",
      "        Matrix res;",
      "",
      "        for (uint32 i = 0; i < _RowCount; ++i)",
      "        {",
      "            for (uint32 j = 0; j < _ItsColumnCount; ++j)",
      "            {",
      "                for (uint32 k = 0; k < _ColumnCount; ++k)",
      "                {",
      "                    res._M_matrix[i][j] += _M_matrix[i][k] * __it._M_matrix[k][j];",
      "                }",
      "            }",
      "        }",
      "",
      "        return res;",
      "    }",
      "",
      "",
      "    template<uint32 _ItsColumnCount>",
      "    Matrix& operator*=(const Matrix<_Tp, _ColumnCount, _ItsColumnCount>& __it)",
      "    {",
      "        swap(*this * __it);",
      "        return *this;",
      "    }",
      "",
      "    template<typename _ValueType>",
      "    std::enable_if_t<std::is_integral_v<_ValueType>, Matrix&> operator^=(_ValueType __pow)",
      "    {",
      "        Matrix res([](uint32 i, uint32 j) -> _Tp { return static_cast<_Tp>(i == j); });",
      "",
      "        for (; __pow; __pow >>= 1, *this *= *this)",
      "        {",
      "            if (__pow & 1)",
      "            {",
      "                res *= *this;",
      "            }",
      "        }",
      "",
      "        swap(std::move(res));",
      "        return *this;",
      "    }",
      "",
      "    constexpr reference at(uint32 __rowNumber, uint32 __colNumber) noexcept",
      "    { return _M_matrix[__rowNumber][__colNumber]; }",
      "",
      "    constexpr value_type at(uint32 __rowNumber, uint32 __colNumber) const noexcept",
      "    { return _M_matrix[__rowNumber][__colNumber]; }",
      "",
      "    void swap(Matrix& __it) noexcept",
      "    {",
      "        for_each([this, &__it](uint32 i, uint32 j) -> void",
      "        {",
      "            _M_matrix[i][j] ^= __it._M_matrix[i][j];",
      "            __it._M_matrix[i][j] ^= _M_matrix[i][j];",
      "            _M_matrix[i][j] ^= __it._M_matrix[i][j];",
      "        });",
      "    }",
      "",
      "    void swap(Matrix&& __it) noexcept",
      "    {",
      "        for_each([this, &__it](uint32 i, uint32 j) -> void",
      "        {",
      "            _M_matrix[i][j] = __it._M_matrix[i][j];",
      "        });",
      "    }",
      "",
      "    constexpr uint32 row_count() const noexcept",
      "    { return _RowCount; }",
      "",
      "    constexpr uint32 column_count() const noexcept",
      "    { return _ColumnCount; }",
      "",
      "    template<typename _Function = void (*)(uint32, uint32)>",
      "    constexpr void for_each(_Function __func)",
      "    {",
      "        for (uint32 i = 0; i < _RowCount; ++i)",
      "        {",
      "            for (uint32 j = 0; j < _ColumnCount; ++j)",
      "            {",
      "                __func(i, j);",
      "            }",
      "        }",
      "    }",
      "",
      "    template<typename _ItsTp, uint32 _ItsRowCount, uint32 _ItsColumnCount>",
      "    friend class Matrix;",
      "",
      "protected:",
      "",
      "    value_type _M_matrix[_RowCount][_ColumnCount];",
      "};",
      "}} // namespace huanhuanonly::math"
    ],
    "description": "Matrix"
  },

  "combinatorics [static]": {
    "prefix": "combinatorics",
    "body": [
      "inline namespace huanhuanonly {",
      "    inline namespace math {",
      "        inline namespace combinatorics",
      "{",
      "using comb_value_type = uint64;",
      "",
      "constexpr auto comb_nmod = static_cast<comb_value_type>(0);",
      "",
      "constexpr auto factorial_max_length = static_cast<std::size_t>(2e5 + 1);",
      "",
      "template<comb_value_type _Mod = comb_nmod>",
      "constexpr auto factorial{ []() constexpr",
      "{",
      "    std::array<comb_value_type, factorial_max_length> a{1};",
      "",
      "    for (std::size_t i = 1; i < a.size(); ++i)",
      "    {",
      "        if constexpr (_Mod != comb_nmod)",
      "        {",
      "            a[i] = a[i - 1] * i % _Mod;",
      "        }",
      "        else",
      "        {",
      "            a[i] = a[i - 1] * i;",
      "        }",
      "    }",
      "",
      "    return a;",
      "}() };",
      "",
      "template<comb_value_type _Mod = comb_nmod>",
      "[[nodiscard]] constexpr comb_value_type C(comb_value_type n, comb_value_type k)",
      "{",
      "    if (n < k)",
      "    {",
      "        return 0;",
      "    }",
      "",
      "    if constexpr (_Mod != comb_nmod)",
      "    {",
      "        return factorial<_Mod>[n] * binary_exponentiation(factorial<_Mod>[n - k] * factorial<_Mod>[k] % _Mod, _Mod - 2, _Mod) % _Mod;",
      "    }",
      "    else",
      "    {",
      "        return factorial<_Mod>[n] / (factorial<_Mod>[n - k] * factorial<_Mod>[k]);",
      "    }",
      "}",
      "",
      "template<comb_value_type _Mod>",
      "[[nodiscard]] constexpr comb_value_type lucas(comb_value_type n, comb_value_type k)",
      "{",
      "    static_assert(_Mod != comb_nmod and _Mod > 1, \"_Mod is required and must be a prime number.\");",
      "",
      "    if (k == 0)",
      "    {",
      "        return 1;",
      "    }",
      "    else",
      "    {",
      "        return C<_Mod>(n % _Mod, k % _Mod) * lucas<_Mod>(n / _Mod, k / _Mod) % _Mod;",
      "    }",
      "}",
      "",
      "template<comb_value_type _Mod = comb_nmod>",
      "[[nodiscard]] constexpr comb_value_type P(comb_value_type n, comb_value_type k)",
      "{",
      "    if (n < k)",
      "    {",
      "        return 0;",
      "    }",
      "",
      "    if constexpr (_Mod != comb_nmod)",
      "    {",
      "        assert(n < factorial_max_length);",
      "        return factorial<_Mod>[n] * binary_exponentiation(factorial<_Mod>[n - k], _Mod - 2, _Mod) % _Mod;",
      "    }",
      "    else",
      "    {",
      "        assert(n < factorial_max_length);",
      "        return factorial<_Mod>[n] / factorial<_Mod>[n - k];",
      "    }",
      "}",
      "",
      "template<comb_value_type _Mod = comb_nmod>",
      "[[nodiscard]] constexpr comb_value_type P(comb_value_type n)",
      "{ return P<_Mod>(n, n); }",
      "",
      "template<comb_value_type _Mod = comb_nmod>",
      "[[nodiscard]] constexpr comb_value_type A(comb_value_type n, comb_value_type k)",
      "{ return P<_Mod>(n, k); }",
      "",
      "template<comb_value_type _Mod = comb_nmod>",
      "[[nodiscard]] constexpr comb_value_type A(comb_value_type n)",
      "{ return P<_Mod>(n, n); }",
      "",
      "template<comb_value_type _MaxN, comb_value_type _MaxK, comb_value_type _Mod = comb_nmod>",
      "[[nodiscard]] constexpr auto comb_table() noexcept",
      "{",
      "    using table_type = std::array<std::array<comb_value_type, _MaxK>, _MaxN>;",
      "",
      "    constexpr table_type table{ []() constexpr",
      "        {",
      "            table_type a{};",
      "",
      "            for (std::size_t i = 0; i < a.size(); ++i)",
      "            {",
      "                a[i][0] = a[i][i] = 1;",
      "",
      "                for (std::size_t j = 1; j < i; ++j)",
      "                {",
      "                    if constexpr (_Mod != comb_nmod)",
      "                    {",
      "                        a[i][j] = (a[i - 1][j] + a[i - 1][j - 1]) % _Mod;",
      "                    }",
      "                    else",
      "                    {",
      "                        a[i][j] = a[i - 1][j] + a[i - 1][j - 1];",
      "                    }",
      "                }",
      "            }",
      "",
      "            return a;",
      "        }()",
      "    };",
      "",
      "    return [&table](comb_value_type n, comb_value_type k) constexpr -> comb_value_type { return table[n][k]; };",
      "}",
      "}}} // namespace huanhuanonly::math::combinatorics"
    ],
    "description": "combinatorics [static]"
  }
}
